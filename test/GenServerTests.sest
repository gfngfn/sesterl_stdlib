import RawValue
import GenServer

module GenServerTests = #[test] struct

  module Server :> sig
    type proc
    type start_error = GenServer.start_link_error
    val start_link<$a> : fun({number : int, name : binary}) -> [$a]result<proc, start_error>
    val stop<$a> : fun(proc) -> [$a]unit
    val set_number<$a> : fun(proc, int) -> [$a]unit
    val get_number<$a> : fun(proc, ?timeout int) -> [$a]int
    val poke<$a> : fun(proc) -> [$a]unit
  end = struct

    type start_error = GenServer.start_link_error

    module Callback = struct

      type request =
        | GetNumber
        | GetName

      type response =
        | Number(int)
        | Name(binary)

      type cast_message =
        | SetNumber(int)

      type state = {number : int,  name : binary}

      type init_arg = state

      type info =
        | Poke

      type global = unit

      type stop_reason = RawValue.t

      val init(state) = act
        let _ = print_debug({"init", state}) in
        GenServer.init_ok(state)

      val handle_call(req, pid, state) = act
        let _ = print_debug({"handle_call", req}) in
        case req of
        | GetNumber -> GenServer.reply(Number(state.number), state)
        | GetName   -> GenServer.reply(Name(state.name), state, ?timeout 0)
        end

      val handle_cast(msg, state) = act
        let _ = print_debug({"handle_cast", msg}) in
        case msg of
        | SetNumber(m) -> GenServer.no_reply({number = m, name = state.name})
        end

      val handle_info(info, state) = act
        case info of
        | Poke ->
            let _ = print_debug("poke") in
            GenServer.no_reply(state)
        end

      val handle_timeout(state) = act
        let _ = print_debug("timeout") in
        GenServer.no_reply(state)

      val terminate(state) = act
        let _ = print_debug("terminate") in
        return({})

    end

    include GenServer.Make(Callback)

    val set_number<$a>(pid : proc, m : int) : [$a]unit = act
      cast(pid, Callback.SetNumber(m))

    val get_number<$a>(pid : proc, ?timeout t_opt) : [$a]int = act
      do res <-
        case t_opt of
        | None    -> call(pid, Callback.GetNumber)
        | Some(t) -> call(pid, Callback.GetNumber, ?timeout t)
        end
      in
      case res of
      | Callback.Number(n) -> return(n)
      end

    val poke(pid : proc) = act
      send(as_pid(pid), Callback.Poke)

  end

  module Main = struct

    val async_increment(pid) = act
      do n <- Server.get_number(pid) in
      do Server.set_number(pid, n + 1) in
      return(n + 1)

    val rec loop(t, pid) = act
      if t <= 0 then
        do n <- Server.get_number(pid) in
        do dummy <- Server.stop(pid) in
        return(n)
      else
        do n <- async_increment(pid) in
        let _ = print_debug({t, n}) in
        loop(t - 1, pid)

    val main(init, t) = act
      do pid_opt <- Server.start_link({number = 57, name = "Sample Store"}) in
      case pid_opt of
      | Error(reason) ->
          let _ = print_debug(format(f'failed to start a process (reason: ~p)', {reason})) in
          return(None)

      | Ok(pid) ->
          do x <- Server.get_number(pid, ?timeout 3000) in
          let _ = print_debug({"first get", x}) in
          do dummy <- Server.poke(pid) in
          do Server.set_number(pid, init) in
          do n <- loop(t, pid) in
          return(Some(n))
      end
  end

  #[test]
  val main_test() =
    Testing.perform("run", fun() -> act
      do res <- Main.main(42, 10) in
      return(assert Testing.equal(-expect Some(52), -got res))
    end)

end
