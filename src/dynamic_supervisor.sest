import ServerUtil
import SupervisorCommon

module DynamicSupervisor = struct
  open ServerUtil

  include SupervisorCommon

  type child_proc<$child_msg> =
    | ChildProcDummy

  val make_child_proc<$b, $child_msg, $c> : fun(fun() -> [$b]option<pid<$child_msg>>) -> [$c]child_proc<$child_msg> = external 1 ```
    make_child_proc(PidOptF) ->
        % io:format("debug L('o' )J make_child_proc, before~n"),
        Ret = PidOptF(),
        % io:format("debug L('o' )J make_child_proc, after~n  ~p~n", [Ret]),
        Ret.
  ```

  type child_spec<$msg, $arg, $child_msg> = {
    start    : frozen<{$arg}, $msg, child_proc<$child_msg>>,
    restart  : restart,
    shutdown : shutdown,
    typ      : worker,
  }

  val make_child_spec<$msg, $arg, $child_msg>(
    -start    start : frozen<{$arg}, $msg, child_proc<$child_msg>>,
    ?restart  restart = Permanent,
    ?shutdown shutdown_opt,
    ?type     typ = Worker,
  ) : child_spec<$msg, $arg, $child_msg> =
    let shutdown =
      case {shutdown_opt, typ} of
      | {Some(shutdown), _} -> shutdown
      | {None, Worker}      -> Timeout(5000)
      | {None, Supervisor}  -> Infinity
      end
    in
    {
      start    = start,
      restart  = restart,
      shutdown = shutdown,
      typ      = typ,
    }

  type sup_flags = {
    intensity : int,
    period    : int,
  }

  val make_sup_flags(?intensity intensity = 1, ?period period = 5) : sup_flags =
    { intensity = intensity, period = period }

  type initialized<$msg, $arg, $child_msg> = option<{sup_flags, child_spec<$msg, $arg, $child_msg>}>

  val init_ok(sup_flags, child_spec) = act
    return(Some({sup_flags, child_spec}))

  val init_fail() = act
    return(None)

  signature Behaviour = sig
    type info :: o
    type init_arg :: o
    type start_arg :: o
    type child_info :: o
    type global :: o
    val init : fun(init_arg) -> [info]initialized<info, start_arg, child_info>
  end

  module Make = fun(Callback : Behaviour) -> #[behaviour("supervisor")] struct

    type proc =
      | ProcDummy

    val init_impl(init_arg) = act
      Callback.init(init_arg)

    val init<$a> : $a = external 1 ```
      init(InitArg) ->
          % io:format("debug L('o' )J (~p) init:~n  ~p~n", [?MODULE, InitArg]),
          case init_impl(InitArg) of
              error ->
                  ignore;

              {ok, {SupFlagsImpl, ChildSpecImpl}} ->
                  #{
                      intensity := Intensity,
                      period    := Period
                  } = SupFlagsImpl,
                  SupFlags = #{
                      strategy  => simple_one_for_one,
                      intensity => erlang:max(Intensity, 0),
                      period    => erlang:max(Period, 1)
                  },
                  #{
                      start    := StartFunc,
                      restart  := Restart,
                      shutdown := ShutdownImpl,
                      typ      := Worker
                  } = ChildSpecImpl,
                  % io:format("debug L('o' )J start func:~n  ~p~n", [StartFunc]),
                  Shutdown =
                      case ShutdownImpl of
                          brutal_kill  -> brutal_kill;
                          {timeout, N} -> max(N, 0);
                          infinity     -> infinity
                      end,
                  ChildSpec = #{
                      id       => ?MODULE,
                      start    => StartFunc,
                      restart  => Restart,
                      shutdown => Shutdown,
                      type     => Worker
                  },
                  {ok, {SupFlags, [ChildSpec]}}
          end.
    ```

    val as_pid : fun(proc) -> pid<Callback.info> = external 1 ```
      as_pid(Pid) -> Pid.
    ```

    val from_pid : fun(pid<Callback.info>) -> proc = external 1 ```
      from_pid(Pid) -> Pid.
    ```

    val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc> = external 1 ```
      start_link(InitArg) ->
          case supervisor:start_link(?MODULE, InitArg) of
              {ok, SupPid} when is_pid(SupPid) -> {ok, SupPid};
              _                                -> error
          end.
    ```

    val start_link_name<$a> : fun(Callback.init_arg, -name name<Callback.global>) -> [$a]option<{bool, proc}> = external 2 ```
      start_link_name(InitArg, NameImpl) ->
          % io:format("debug L('o' )J (~p) start_link_name (pre):~n  ~p~n", [?MODULE, InitArg]),
          Name =
              case NameImpl of
                  {local, Bin} -> {local, erlang:binary_to_atom(Bin, utf8)};
                  {global, X}  -> {global, {?MODULE, X}}
              end,
          % io:format("debug L('o' )J (~p) start_link_name (arg):~n  ~p~n", [?MODULE, InitArg]),
          StartRet = supervisor:start_link(Name, ?MODULE, InitArg),
          % io:format("debug L('o' )J (~p) start_link_name (ret):~n  ~p~n", [?MODULE, StartRet]),
          case StartRet of
              {ok, SupPid} when erlang:is_pid(SupPid) -> {ok, {true, SupPid}};
              {error, {already_started, SupPid}}      -> {ok, {false, SupPid}};
              _                                       -> error
          end.
    ```

    val where_is_local<$a> : fun(binary) -> [$a]option<proc> = external 1 ```
      where_is_local(NameBin) ->
          NameAtom = erlang:binary_to_atom(NameBin, utf8),
          case erlang:whereis(NameAtom) of
              Pid when erlang:is_pid(Pid) -> {ok, Pid};
              _                           -> error
          end.
    ```

    val where_is_global<$a> : fun(Callback.global) -> [$a]option<proc> = external 1 ```
      where_is_local(X) ->
          case erlang:whereis({?MODULE, X}) of
              Pid when erlang:is_pid(Pid) -> {ok, Pid};
              undefined                   -> error
          end.
    ```

    val start_child<$a> : fun(proc, Callback.start_arg) -> [$a]option<pid<Callback.child_info>> = external 2 ```
      start_child(SupPid, StartArg) ->
          % io:format("debug L('o' )J (~p) start_child (arg):~n  ~p~n", [?MODULE, StartArg]),
          StartRet = supervisor:start_child(SupPid, [StartArg]),
          % io:format("debug L('o' )J (~p) start_child (ret):~n  ~p~n", [?MODULE, StartRet]),
          case StartRet of
              {ok, ChildPid} when is_pid(ChildPid) -> {ok, ChildPid};
              _                                    -> error
          end.
    ```

  end

end
